<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Tape Snake</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{ margin:0; background:#151821; color:#dbe2ff; font-family:monospace }
    #c{ display:block; margin:0 auto; image-rendering:pixelated; }
    .ui{position:fixed;inset:0;pointer-events:none}
    .top{position:absolute;left:8px;top:6px;font-size:14px;opacity:.9}
    .center{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center}
    .btn{display:inline-block;margin-top:10px;padding:6px 10px;border:1px solid #dbe2ff;border-radius:6px}
  </style>
</head>
<body>
<canvas id="c" width="720" height="504"></canvas>
<div class="ui">
  <div class="top" id="hud">Score: 0 路 High: 0 路 Speed: 1</div>
  <div class="center" id="overlay"></div>
</div>

<script>
/* ===== Canvas & constants ===== */
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

const TILE = 24;
const COLS = Math.floor(canvas.width / TILE);
const ROWS = Math.floor(canvas.height / TILE);
const BOX_PAD = 3;

const COL = {
  bg: "#0e1116",
  tape: "#f5d27b",
  tapeSeam: "#e9c56a",
  text: "#dbe2ff"
};

/* ===== Background using tiles.png ===== */
const TILESET_SIZE = 16;
const TILE_SCALE = 3;
const TILE_COL = 2;
const TILE_ROW = 1;
const TILE_GUTTER = 0;

const tileset = new Image();
tileset.src = 'tiles.png';
let bgPattern = null;

tileset.onload = () => {
  bgPattern = makePatternFromTile(tileset, TILESET_SIZE, TILE_COL, TILE_ROW, TILE_SCALE, TILE_GUTTER);
};

function makePatternFromTile(img, tileSize, col, row, scale=3, gutter=0){
  const sx = col * (tileSize + gutter) + gutter;
  const sy = row * (tileSize + gutter) + gutter;

  const off = document.createElement('canvas');
  off.width  = tileSize * scale;
  off.height = tileSize * scale;
  const octx = off.getContext('2d');
  octx.imageSmoothingEnabled = false;
  octx.drawImage(img, sx, sy, tileSize, tileSize, 0, 0, off.width, off.height);

  return ctx.createPattern(off, 'repeat');
}

/* ===== Box sprites ===== */
const BOX_FILES = ['Sprite-0020.png','Sprite-0021.png','Sprite-0022.png','Sprite-0023.png'];
const BOX_SPRITES = BOX_FILES.map(src => { const i = new Image(); i.src = src; return i; });

function randInt(n){ return Math.floor(Math.random()*n); }
function randChoice(arr){ return arr[randInt(arr.length)]; }
function randRotation(){ return (randInt(4) * Math.PI) / 2; }

/* ===== Game state ===== */
let state = "menu";
let score = 0, highScore = Number(localStorage.getItem("highScore") || 0);
let speed = 8;
let levelSpeed = 1;
let tick = 0;

let snake, dir, nextDir, food, tailGrow;

const INPUTS = [];
const DIRS = {
  ArrowUp:{x:0,y:-1}, ArrowDown:{x:0,y:1}, ArrowLeft:{x:-1,y:0}, ArrowRight:{x:1,y:0},
  w:{x:0,y:-1}, s:{x:0,y:1}, a:{x:-1,y:0}, d:{x:1,y:0}
};

addEventListener('keydown', e=>{
  if (e.key==='p'||e.key==='P'){ state = state==='playing' ? 'paused' : (state==='paused' ? 'playing' : state); showOverlay(); return; }
  if (e.key==='r'||e.key==='R'){ reset(); state='playing'; showOverlay(); return; }
  if (state==='menu'){ reset(); state='playing'; showOverlay(); return; }
  if (state==='gameOver'){ reset(); state='playing'; showOverlay(); return; }
  const v = DIRS[e.key]; if(!v) return; INPUTS.push(v);
});

function reset(){
  score = 0;
  speed = 8;
  levelSpeed = 1;
  tick = 0;
  snake = [{x:5, y:(ROWS/2|0)}];
  dir = {x:1,y:0};
  nextDir = dir;
  tailGrow = 0;
  food = spawnFood();
  updateHUD();
}

function spawnFood(){
  while(true){
    const candidate = {x:(Math.random()*COLS|0), y:(Math.random()*ROWS|0)};
    if (snake.some(s=>s.x===candidate.x && s.y===candidate.y)) continue;

    const sprite = randChoice(BOX_SPRITES);
    const rotation = randRotation();
    return { ...candidate, sprite, rotation };
  }
}

function consumeInput(){
  while (INPUTS.length){
    const cand = INPUTS.shift();
    if (snake.length>1 && cand.x===-dir.x && cand.y===-dir.y) continue;
    nextDir = cand; return;
  }
}

/* ===== Update / Draw ===== */
function update(){
  if (state!=='playing') return;
  tick++;
  if (tick % speed) return;

  consumeInput();
  dir = nextDir;

  const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

  if (head.x<0 || head.y<0 || head.x>=COLS || head.y>=ROWS){ state='gameOver'; persistHighScore(); showOverlay(); return; }
  if (snake.some(s=>s.x===head.x && s.y===head.y)){ state='gameOver'; persistHighScore(); showOverlay(); return; }

  snake.unshift(head);

  if (head.x===food.x && head.y===food.y){
    score += 10;
    tailGrow += 1;
    food = spawnFood();
    if (score % 50 === 0 && speed > 4){ speed--; levelSpeed++; }
    updateHUD();
  }

  if (tailGrow>0) tailGrow--; else snake.pop();
}

function draw(){
  if (bgPattern){
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.fillStyle = bgPattern;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.restore();
  } else {
    ctx.fillStyle = COL.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  drawFood(food.x, food.y, food.sprite, food.rotation);
  drawTape();
}

function drawFood(gx, gy, sprite, rotationRad){
  const tileX = gx * TILE;
  const tileY = gy * TILE;

  if (!sprite || !sprite.complete || sprite.naturalWidth === 0){
    ctx.fillStyle = "#c9a66b";
    ctx.fillRect(tileX+BOX_PAD, tileY+BOX_PAD, TILE-BOX_PAD*2, TILE-BOX_PAD*2);
    return;
  }

  const drawSize = TILE - BOX_PAD*2;
  const cx = tileX + TILE/2;
  const cy = tileY + TILE/2;

  ctx.save();
  ctx.imageSmoothingEnabled = false;
  ctx.translate(cx, cy);
  ctx.rotate(rotationRad);
  ctx.drawImage(sprite, -drawSize/2, -drawSize/2, drawSize, drawSize);
  ctx.restore();
}

function drawTape(){
  for (let i=0;i<snake.length;i++){
    const s = snake[i], x = s.x*TILE, y = s.y*TILE;
    ctx.fillStyle = COL.tape; ctx.fillRect(x+2, y+2, TILE-4, TILE-4);
    ctx.fillStyle = COL.tapeSeam; ctx.fillRect(x+2, y+(TILE/2|0), TILE-4, 2);

    if (i===0){
      ctx.fillStyle = "#fadf95";
      if (dir.x===1){ ctx.fillRect(x+TILE-4, y+6, 4, TILE-12); }
      else if (dir.x===-1){ ctx.fillRect(x, y+6, 4, TILE-12); }
      else if (dir.y===1){ ctx.fillRect(x+6, y+TILE-4, TILE-12, 4); }
      else if (dir.y===-1){ ctx.fillRect(x+6, y, TILE-12, 4); }
    }
  }
}

/* ===== HUD / Overlay ===== */
const hud = document.getElementById('hud');
const overlay = document.getElementById('overlay');

function persistHighScore(){
  if (score > highScore){
    highScore = score;
    localStorage.setItem("highScore", String(highScore));
  }
}

function updateHUD(){
  hud.textContent = `Score: ${score} 路 High: ${highScore} 路 Speed: ${levelSpeed}`;
}

function showOverlay(){
  if (state==='menu'){
    overlay.innerHTML = `<div><h1>TAPE SNAKE</h1><div>Seal cartons. Avoid jams.</div><div>Arrow Keys or WASD</div><div class="btn">Press any key to start</div></div>`;
  } else if (state==='paused'){
    overlay.innerHTML = `<div><h2>Paused</h2><div class="btn">Press P to resume</div></div>`;
  } else if (state==='gameOver'){
    overlay.innerHTML = `<div><h2>Line Jammed!</h2><div>Score: ${score} (High: ${highScore})</div><div class="btn">Press R to restart</div></div>`;
  } else {
    overlay.innerHTML = '';
  }
  overlay.style.display = (state==='playing') ? 'none' : 'block';
}

/* ===== Main loop ===== */
function loop(){ update(); draw(); requestAnimationFrame(loop); }
reset(); showOverlay(); loop();
</script>
</body>
</html>
